### Образец простейшего многослойного Spring boot веб приложения.

#### Для входа используйте:</br>
**login:** admin</br>
**password:** admin

#### Слои:
+ **Controller** - обрабатывает команды от браузера
+ **Service** - обработка бизнес логики
+ **DAL(data access layer)** - общение с БД

После апдейта приложения, функции слоя Сервиса взял на себя Репозиторий. Благодаря наследованию от CrudRepository, репозиторий может выполнять самые различные команды.

#### Приложение может:
+ Добавлять нового пользователя
+ Производить аутентификацию пользователя - В ЭТОМ АПДЕЙТЕ НЕ РАБОТАЕТ
+ Инициализация БД H2 (с данными)
+ Выводить список всех пользователей
+ Редактировать и удалять пользователей

### Особенности
**POM.XML:**
+ spring-boot-starter-web - необходим для работы spring boot
+ spring-boot-starter-data-jpa - необходим для работы spring boot с БД
+ h2 - добавление БД H2
+ lombok - удобная утилита, теперь в классах не нужно ставить сетеры, гетеры и конструкторы
+ validation-api - необходим для выставления условий валидности полям БД, при инициализации БД через аннотацию @Entity
+ thymeleaf - современная замена jps-страницам (см. аннотации th в html)

В папке с ресурсами присутствует две директории:
+ static - для статических страниц
+ templates - для страниц thymeleaf

В настроечном файле application.properties со свойствами для spring стоит свойство:
spring.h2.console.enabled=true.
Такое свойство позволяет зайти в консоль БД по адресу: http://localhost:8080/h2-console/

В файле application.properties есть свойство с путём до БД: spring.datasource.url=jdbc:h2:mem:test. Там так же можно указать путь для инициализации БД. Но, в этом случае, при использовании метода GET в контроллере, каждый раз будет пытаться создаться новая БД по этому пути.

В spring boot по умолчанию запускаются sql файлы со следующими именами:
+ date.sql - заполнение БД
+ schema.sql - инициализация БД - В ДАННОМ АПДЕЙТЕ ЭТОТ ФАЙЛ УДАЛЕН
Инициализация БД происходит благодаря аннотации @Entity (и правильной аннотации полей)

Основной класс App (да и всё приложение) лежит в отдельном пакете (в нашем случае пакет: app), это сделано специально, иначе spring не заработает.

~~В Controller используются аннотации @GetMapping, а не @PostMapping, т.к. spring не даёт использовать метод Post.~~ </br>
В Controller можно используются только аннотации @GetMapping и @PostMapping, но не @PutMapping и @DeleteMapping, т.к. thymeleaf сам сделает запросы DELETE и PUT там где это необходимо.
Но, если хочется, то можно использовать @PutMapping и @DeleteMapping, для этого:
* в проперти файле ставится свойство: spring.mvc.hiddenmethod.filter.enabled=true
* выставляются соответствующие аннотации @PutMapping и @DeleteMapping у нужных методов
* в html файлах (в формах) проставляются методы: th:method="PUT"

----------

**Spring Security**

Классы MvcConfig и WebSecurityConfig служат конфигуратами для Spring Security.
MvcConfig мапит страницы, которые нигде не будут описаны, сдесь SS узнаёт что такие страницы есть.
WebSecurityConfig.configure - идёт настройка доступа к ресурсам.
.csrf().disable() - отключил csrf защиту, иначе не работает логаут
Метод userDetailsService в WebSecurityConfig создаёт пользователя в inMemory
Этот блок добавлен для безопасного логаута (меняется на метод POST, а не GET, чистятся куки, идёт редирект на страницу входа):
.logout()
.logoutRequestMatcher(new AntPathRequestMatcher("/logout", "POST"))
.invalidateHttpSession(true)
.clearAuthentication(true)
.deleteCookies("JSESSIONID")
.logoutSuccessUrl("/login");

Для корректной работы консоли H2 необходимо отключить X-Frame-Options in Spring Security. Для этого добавил в метод: WebSecurityConfig.configure cktle.oe. cnhjxre^
http.headers().frameOptions().disable();

Используется в БД имя роли с префиксом "ROLE_", т.к. такой префикс автоматически подставляет Spring Security (при проверке по .hasRole, но при проверке по .hasAuthority, префикс не учитывается)

На странице регистрации пользователя (там же админ может добавить пользователя) add-user.html убрал action из формы. Т.о. первоначальный get запрос превращается в post запрос при нажатии кнопки, при этом значение запроса сохраняется (/register для админа или /signup для не аутенфицированных пользователей)

ConnectionManager - больше не используется. Спринг сам пропертей берёт настройки для поднятия базы.

Контроллеры распределены по ролям.

@GetMapping("/register") и @PostMapping("/register") при разных типах запроса, происходят разные действия.

В html страницах, благодаря thymeleaf осуществляется показ определенного текста в зависимости от роли юзера. Яркий пример на странице индекса.

--------

**Test**

Создан абстрактный класс для спринговых тестов: AbstractSpringTest. Далее от него можно наследоваться всем классам тестов. Но можно расставлять такие же аннотации как у абстрактного класса, не создавая этого абстрактного класса.
При запуске теста в IDEA, необходимо смотреть, чтобы в настройках конфигурации запуска была выставлена рабочая папка проекта.

Используя аннотации в тестовом классе, можно прописать что делать перед/после запуском класса/метода. Обрати внимание: в Junit4 аннотации @Before/@After и @BeforeClass/@AfterClass, в Junit5 @BeforeEach/@AfterEach, @AfterAll/@BeforeAll.

В тестах, assertThat может быть устаревшим (в Junit5). Чтобы IDAE не ругалась, можно заменить импорт: org.junit.Assert.assertThat --> org.hamcrest.MatcherAssert.assertThat (неясно на сколько это правильное решение)

После выполнения каждого метода в тесте, UserService инициализируется заново, т.е. файл data.sql, исполняется каждый раз перед тестом.

Для работы assertThrows добавил импорт org.junit.jupiter.api.Assertions.assertThrows;

@SpringBootTest - запускает сервер с БД. В атрибутах можно прописать как запускать, по умолчанию стоит: MOCK
@AutoConfigureMockMvc - это автоконфигуратор MOCK для аннотации @SpringBootTest, без него @SpringBootTest не запуститься
@Transactional - откатывает в изначальное состояние после каждого тестового метода
Если используется JUnit4, то необходимо добавить @RunWith(SpringRunner.class)
